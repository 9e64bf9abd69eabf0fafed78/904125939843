# Linux

---

## 进程间通信方式

https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg

|        |  实现  |       限制        | 场景  |           示例            |
|:-------|:----:|:---------------:|:---:|:-----------------------:|
| 管道     | 管道符号 | 只能应用于父子进程间通信、单向 |     |   `ps -ef ▏grep java`   |
| MQ     |      |   非实时、携带数据量少    |     |                         |
| 共享内存   |      |                 |     |                         |
| 信号量    |      |                 |     |                         |
| 信号     |      |                 |     | `Ctrl+C`、`kill -9 5858` |
| socket |      |                 |     |                         |

## 线程间同步方式

- **互斥量(`Mutex`)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
- **信号量(`Semaphore`)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- **事件(`Event`)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
-

## 进程调度算法

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## BIO/NIO/AIO

* ***同步阻塞***：傻等着水开
* ***同步非阻塞***：等水开的间隙做其他事
* ***异步非阻塞***：水开会自动发送通知

|     | BIO  | NIO  | AIO  |
|:---:|:----:|:----:|:----:|
| 管道  | 同步阻塞 | 同步阻塞 | 同步阻塞 |
